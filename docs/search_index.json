[["index.html", "Initiation au langage R Chapitre 1 R 1.1 Qu’est-ce que le logiciel R ? 1.2 Installer R 1.3 RStudio Desktop 1.4 Quelques commandes de base R", " Initiation au langage R Cédric HASSEN-KHODJA Chapitre 1 R 1.1 Qu’est-ce que le logiciel R ? R1 est un langage de programmation et un environnement de développement (posit) utilisés pour le calcul statistique et la visualisation des données. Il est largement utilisé par les scientifiques, les analystes et les développeurs pour analyser et visualiser des données, développer des applications et créer des algorithmes. Il offre une variété de fonctionnalités, notamment des outils pour le traitement et la manipulation de données, des packages pour le traitement des données et des bibliothèques pour le traitement des données. R(R Core Team 2022) est disponible pour de nombreuses plateformes, notamment Windows, Mac OS X et Linux. Il est également disponible sous forme de packages pour les systèmes d’exploitation populaires, tels que Ubuntu, Red Hat et Debian. 1.2 Installer R Pour installer R sous Windows, Linux ou macOS vous devez d’abord télécharger le package d’installation à partir du site Web officiel de R (CRAN) ou sur un de ses miroir2. Sous Windows ou sous MacOS, une fois le package téléchargé, double-cliquez sur le fichier d’installation et suivez les instructions à l’écran pour compléter l’installation. Sous Linux3, suivez les instructions à l’écran pour faire l’installation de R. 1.3 RStudio Desktop RStudio Desktop est une application de bureau qui offre une interface utilisateur graphique (GUI) pour le langage de programmation R. Il fournit un environnement de développement intuitif pour le codage, le débogage et la visualisation des données. Il offre également des outils pour l’analyse statistique, le traitement des données et la génération de rapports. RStudio Desktop4 est disponible pour Windows, Mac OS X et Linux. Pour avoir un aperçu des différentes possibilités qu’offre l’interface vous pouvez récupérer le cheat sheet5 dédié. Pour commencer, vous pouvez créer un nouveau projet R en utilisant le menu File &gt; New project. Dans la fenêtre suivante, choisissez New directory pour créer un répertoire de travail sur votre ordinateur ou Open directory si vous avez déjà un répertoire de travail. Dans la fenêtre suivante, choisissez New Project et créez un répertoire MyFirstProject sur le bureau (ou ailleurs) et validez par Create Project. Voici un nouveau projet ! Créez un nouveau script R à l’intérieur du projet MyFirstProject en utilisant File -&gt; New File et choisissez Rscript. Le nouveau script est ouvert dans une fenêtre Untitled1. Pour l’enregistrer, utilisez File -&gt; Save as et donnez-lui un nom, par exemple MyFirstScript. Il est automatiquement enregistré dans le répertoire MyFirstProject. Fermez RStudio avec File -&gt; Quit Session.  Mon premier script ! Vérifiez que dans le répertoire MyFirstProject vous avez maintenant ces trois éléments : un dossier .Rproj.user un fichier MyFirstProject.Rproj un script myFirstScript.R 1.4 Quelques commandes de base R install.packages() : installe un package R. library() : charge un package R. search() : recherche un package R. update.packages() : met à jour un package R. remove.packages() : supprime un package R. options() : affiche les options de configuration R. setwd() : définit le répertoire de travail R. getwd() : affiche le répertoire de travail R. save.image() : sauvegarde l’environnement R. Voici les sorties de quelques commandes pré-citées : install.packages(&quot;dplyr&quot;) ## Installation du package dans &#39;/home/cedric/R/x86_64-pc-linux-gnu-library/4.2&#39; ## (car &#39;lib&#39; n&#39;est pas spécifié) library(&quot;dplyr&quot;) ## ## Attachement du package : &#39;dplyr&#39; ## Les objets suivants sont masqués depuis &#39;package:stats&#39;: ## ## filter, lag ## Les objets suivants sont masqués depuis &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union getwd() ## [1] &quot;/home/cedric/Documents/FormationR _Banyuls&quot; References "],["le-langage-r.html", "Chapitre 2 Le langage R 2.1 Elément de base du langage : le vecteur 2.2 Opérations sur les vecteurs 2.3 La matrice : un objet à deux dimensions 2.4 La liste 2.5 Le tableau de données 2.6 Concaténer des objets R en lignes ou en colonnes 2.7 Les fonctions et les librairies (packages) R", " Chapitre 2 Le langage R 2.1 Elément de base du langage : le vecteur Les vecteurs sous R sont des objets unidimensionnels qui contiennent des éléments de même type (numériques, chaînes de caractères, etc.). Ils sont créés à l’aide de la fonction c() et peuvent être modifiés à l’aide des opérateurs arithmétiques et des fonctions spécifiques. Les vecteurs peuvent également être indexés et manipulés à l’aide de fonctions comme subset(), sort(), et merge(). Les vecteurs sont une partie essentielle de la programmation en R et sont très utiles pour stocker et manipuler des données. Utiliser la fonction c() pour créer un vecteur à partir d’une liste: v1 &lt;- c(1, 2, 3, 4, 5) v1 ## [1] 1 2 3 4 5 Utiliser la fonction seq() pour créer un vecteur de valeurs entières: v2 &lt;- seq(1, 10) v2 ## [1] 1 2 3 4 5 6 7 8 9 10 Utiliser la fonction rep() pour créer un vecteur avec des valeurs répétées: v3 &lt;- rep(1, 5) v3 ## [1] 1 1 1 1 1 Utiliser la fonction seq_len() pour créer un vecteur avec des valeurs équidistantes: v4 &lt;- seq_len(5) Utiliser la fonction vector() pour créer un vecteur vide: v5 &lt;- vector() v5 ## logical(0) La fonction length() permet de connaître la taille d’un vecteur. La fonction mode() permet de connaître le type d’un vecteur: v4 &lt;- seq_len(5) length(v4) ## [1] 5 mode(v4) ## [1] &quot;numeric&quot; Pour sélectionner un élément d’un vecteur vous pouvez utiliser les [] en spécifiant l’index. Si vous souhaitez extraire plusieurs éléments, il faut utiliser la fonction de concaténation c(). Exemple: animals &lt;- c(&quot;lyon&quot;, &quot;chat&quot;, &quot;oiseau&quot;) animals[1] ## [1] &quot;lyon&quot; animals[c(1,3)] ## [1] &quot;lyon&quot; &quot;oiseau&quot; Un facteur est un type de données utilisé pour stocker des valeurs catégoriques sous R. Les facteurs sont souvent utilisés pour représenter des variables qualitatives telles que des étiquettes de couleur, des groupes d’âge, des sexes, etc. Les facteurs sont stockés sous forme de nombres entiers, mais peuvent être affichés sous forme de chaînes de caractères. Utiliser la fonction factor() pour créer un facteur à partir d’une liste de chaînes de caractères: f1 &lt;- factor(c(&quot;rouge&quot;, &quot;bleu&quot;, &quot;vert&quot;)) f1 ## [1] rouge bleu vert ## Levels: bleu rouge vert Utiliser la fonction as.factor() pour créer un facteur à partir d’une liste de nombres entiers: f2 &lt;- as.factor(c(1, 2, 3)) f2 ## [1] 1 2 3 ## Levels: 1 2 3 Utiliser la fonction cut() pour créer un facteur à partir d’une liste de nombres: f3 &lt;- cut(c(1, 2, 3, 4, 5), breaks = c(1, 3, 5)) f3 ## [1] &lt;NA&gt; (1,3] (1,3] (3,5] (3,5] ## Levels: (1,3] (3,5] Utiliser la fonction levels() pour définir des niveaux pour un facteur existant: f4 &lt;- factor(c(&quot;rouge&quot;, &quot;bleu&quot;, &quot;vert&quot;)) levels(f4) &lt;- c(&quot;rouge&quot;, &quot;jaune&quot;, &quot;vert&quot;) f4 ## [1] jaune rouge vert ## Levels: rouge jaune vert Utiliser la fonction relevel() pour modifier l’ordre des niveaux d’un facteur existant: f5 &lt;- factor(c(&quot;rouge&quot;, &quot;bleu&quot;, &quot;vert&quot;)) relevel(f5, ref = &quot;rouge&quot;) ## [1] rouge bleu vert ## Levels: rouge bleu vert 2.2 Opérations sur les vecteurs Les opérations sur les vecteurs peuvent être utilisées pour effectuer des opérations arithmétiques, des opérations logiques ou des opérations de comparaison. Utiliser l’opérateur + pour additionner deux vecteurs: vec1 &lt;- c(1, 2, 3) vec2 &lt;- c(4, 5, 6) vec1 + vec2 ## [1] 5 7 9 Utiliser l’opérateur - pour soustraire deux vecteurs: vec1 &lt;- c(1, 2, 3) vec2 &lt;- c(4, 5, 6) vec1 - vec2 ## [1] -3 -3 -3 Utiliser l’opérateur * pour multiplier deux vecteurs: vec1 &lt;- c(1, 2, 3) vec2 &lt;- c(4, 5, 6) vec1 * vec2 ## [1] 4 10 18 Utiliser l’opérateur &amp; pour effectuer un ET logique entre deux vecteurs: vec1 &lt;- c(TRUE, FALSE, TRUE) vec2 &lt;- c(FALSE, FALSE, TRUE) vec1 &amp; vec2 ## [1] FALSE FALSE TRUE Utiliser l’opérateur | pour effectuer un OU logique entre deux vecteurs: vec1 &lt;- c(TRUE, FALSE, TRUE) vec2 &lt;- c(FALSE, FALSE, TRUE) vec1 | vec2 ## [1] TRUE FALSE TRUE Utiliser l’opérateur ! pour effectuer un NON logique sur un vecteur: vec &lt;- c(TRUE, FALSE, TRUE) !vec ## [1] FALSE TRUE FALSE Utiliser l’opérateur == pour vérifier si une valeur est égal à un élément du vecteur: x &lt;- c(1, 2, 3) x == 2 ## [1] FALSE TRUE FALSE Utiliser l’opérateur &gt; pour vérifier si une valeur est strictement supérieure à un des éléments du vecteur: x &lt;- c(1, 2, 3) x &gt; 2 ## [1] FALSE FALSE TRUE Utiliser l’opérateur &lt; pour vérifier si une valeur est strictement inférieure à un des éléments du vecteur: x &lt;- c(1, 2, 3) x &lt; 2 ## [1] TRUE FALSE FALSE Utiliser l’opérateur %in% pour vérifier si une valeur est incluse dans le vecteur: x &lt;- c(1, 2, 3) 2 %in% x ## [1] TRUE Utiliser l’opérateur %nin% (librairie Hmisc) pour vérifier si une valeur n’est pas incluse dans le vecteur : library(Hmisc) x &lt;- c(1, 2, 3) 2 %nin% x ## [1] FALSE 2.3 La matrice : un objet à deux dimensions Les matrices sont une structure de données importante sous R. Elles sont utilisées pour stocker des données qui peuvent être représentées sous forme de tableau à deux dimensions. Les matrices sous R peuvent être créées à l’aide des fonctions matrix() et cbind(). Par exemple, pour créer une matrice 3x3 avec des valeurs de 1 à 9, vous pouvez utiliser la commande suivante: mat &lt;- matrix(1:9, nrow = 3, ncol = 3, byrow = TRUE) mat ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 ## [3,] 7 8 9 Ceci créerait une matrice 3x3 avec les valeurs 1, 2, 3 dans la première ligne, 4, 5, 6 dans la deuxième ligne et 7, 8, 9 dans la troisième ligne. Vous pouvez également utiliser la fonction cbind() pour créer une matrice à partir de vecteurs. Par exemple, pour créer une matrice 3x3 avec des valeurs de 1 à 9, vous pouvez utiliser la commande suivante: mat &lt;- cbind(c(1, 4, 7), c(2, 5, 8), c(3, 6, 9)) mat ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 ## [3,] 7 8 9 2.4 La liste Les listes sous R sont très utiles car elles peuvent contenir des éléments de différents types (par exemple, des chaînes de caractères, des nombres, des vecteurs, etc.). Les listes sous R peuvent être créées à l’aide de la fonction list(). Par exemple, pour créer une liste avec des valeurs de 1 à 9, vous pouvez utiliser la commande suivante: l &lt;- list(1, 2, 3, 4, 5, 6, 7, 8, 9) l ## [[1]] ## [1] 1 ## ## [[2]] ## [1] 2 ## ## [[3]] ## [1] 3 ## ## [[4]] ## [1] 4 ## ## [[5]] ## [1] 5 ## ## [[6]] ## [1] 6 ## ## [[7]] ## [1] 7 ## ## [[8]] ## [1] 8 ## ## [[9]] ## [1] 9 Les listes sous R peuvent également être indexées et manipulées facilement. Par exemple, pour extraire le premier élément de la liste précédente, vous pouvez utiliser la commande suivante: first_element &lt;- l[1] first_element ## [[1]] ## [1] 1 2.5 Le tableau de données Les data.frame sous R sont une structure de données très importante pour le traitement des données. Les data.frame sont des objets qui contiennent des données organisées sous forme de tableau, avec des lignes et des colonnes. Les lignes représentent des enregistrements et les colonnes des variables. Les data.frame sont très flexibles et peuvent contenir des données de différents types, y compris des chaînes de caractères, des entiers, des nombres réels, des dates, etc. Les data.frame sont très faciles à manipuler, à trier et à filtrer. On peut également facilement effectuer des opérations de jointure entre deux data.frame. Vous pouvez utiliser la commande data.frame() pour créer un data.frame: df &lt;- data.frame(X1 = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), X2 = c(10, 20, 30), X3 = c(0.5, 0.7,0.9)) df ## X1 X2 X3 ## 1 A 10 0.5 ## 2 B 20 0.7 ## 3 C 30 0.9 Le data.frame ci-dessus a deux colonnes (X1, X2 et X3) et trois lignes. La première colonne contient des chaînes de caractères (A, B et C), la deuxième colonne contient des entiers (10, 20 et 30) et la troisième colonne contient des nombres réels (0.5, 0.7 et 0.9). On peut extraire une colonne du data.frame par son nom ou par son index: df$X1 ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; df[,1] ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; On peut facilement effectuer des opérations d’agrégation sur le data.frame df, par exemple pour calculer la moyenne des valeurs de la colonne X2: mean(df$X2) ## [1] 20 2.6 Concaténer des objets R en lignes ou en colonnes La concaténation des objets R en lignes ou en colonnes est une fonction très utile pour fusionner plusieurs objets en un seul. Les fonctions rbind() et cbind() permettent de coller des objets R (vecteurs, matrices ou tableau de données) soit par lignes (rbind pour row) soit par colonnes (cbind pour column). Voici quelques exemples de concaténation en lignes ou en colonnes: Concaténation en lignes: # Création des objets a &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) b &lt;- c(&quot;D&quot;, &quot;E&quot;, &quot;F&quot;) # Concaténation en lignes rbind(a, b) ## [,1] [,2] [,3] ## a &quot;A&quot; &quot;B&quot; &quot;C&quot; ## b &quot;D&quot; &quot;E&quot; &quot;F&quot; Concaténation en colonnes: # Création des objets a &lt;- 1:3 b &lt;- 4:6 # Concaténation en lignes cbind(a, b) ## a b ## [1,] 1 4 ## [2,] 2 5 ## [3,] 3 6 Exercices: Créer les 3 vecteurs suivants et vérifier qu’ils apparaissent dans la fenêtre « Global environment » en haut à droite: a, un vecteur alphanumérique (caractère) contenant les noms de 5 animaux; b un vecteur numérique de longueur 10 contenant les nombres entiers de 1 à 10; c un vecteur logique de longueur 5, composé de faux, vrai, faux, vrai, vrai. Utiliser les différentes fonctions que nous avons vues pour vérifier le contenu, la longueur, le type de ces trois vecteurs. Générer un facteur af à partir du vecteur a et vérifier le type de ces deux vecteurs. Constituer une matrice m de dimension [10,3] à partir du vecteur a, du vecteur b et du vecteur c. Qu’observez-vous ? Quel est le mode de m ? Affichez la première colonne de m. Idem pour une matrice mf à partir de af, b et c. Quel est le mode de mf ? Supprimer de af le premier élément et mettre à jour l’attribut levels. 2.7 Les fonctions et les librairies (packages) R 2.7.1 Les fonctions R Une fonction sous R est une série d’instructions qui effectuent une tâche spécifique. La syntaxe d’une fonction en R est très similaire à celle des autres langages de programmation, avec une déclaration de fonction, des paramètres optionnels et des instructions à l’intérieur de la fonction. La déclaration de fonction commence par le mot-clé “function” suivi du nom de la fonction. Les paramètres optionnels sont définis entre parenthèses après le nom de la fonction et les instructions à l’intérieur de la fonction sont écrites entre accolades. Une fonction se termine généralement par le mot-clé “return”, qui indique le résultat de la fonction. Voici un exemple de création et d’appel de fonction sous R: #Création de la fonction add &lt;- function(a, b){ return(a + b) } #Appel de la fonction resultat &lt;- add(2, 3) #Afficher le résultat print(resultat) ## [1] 5 Le résultat de l’appel de la fonction est 5. 2.7.2 Les librairies de fonctions sous R Les librairies de fonctions sont des packages R qui contiennent des fonctions prédéfinies et des outils pour effectuer des tâches spécifiques. Ces librairies peuvent être installées à partir des dépôts CRAN ou des dépôts GitHub. Les librairies les plus populaires incluent ggplot2, dplyr, tidyr, lubridate et stringr. Ces librairies peuvent être utilisées pour effectuer des tâches telles que le traitement de texte, la manipulation de données, la visualisation de données et le calcul statistique. Pour installer un package sous RStudio, vous devez utiliser l’onglet Packages de la fenêtre en bas à droite, et on choisit Install pour installer le package. Sinon ceci se fait via la fonction install.packages(). Installer un package sous CRAN ou à partir d’une archive! Une fois le package installé, vous pouvez charger le package à l’aide de la fonction library()ou en cochant la case devant le package dans la fenêtre Packages. Charger un package comme dplyr! Vous pouvez également utiliser la commande require() pour charger le package uniquement si le package n’est pas déjà chargé. Une fois le package chargé, vous pouvez utiliser les fonctions et les outils fournis par le package. Le code ci-dessous permet d’installer et charger le package plyr. install.packages(&quot;plyr&quot;) ## Installation du package dans &#39;/home/cedric/R/x86_64-pc-linux-gnu-library/4.2&#39; ## (car &#39;lib&#39; n&#39;est pas spécifié) library(plyr) ## ------------------------------------------------------------------------------ ## You have loaded plyr after dplyr - this is likely to cause problems. ## If you need functions from both plyr and dplyr, please load plyr first, then dplyr: ## library(plyr); library(dplyr) ## ------------------------------------------------------------------------------ ## ## Attachement du package : &#39;plyr&#39; ## Les objets suivants sont masqués depuis &#39;package:Hmisc&#39;: ## ## is.discrete, summarize ## Les objets suivants sont masqués depuis &#39;package:dplyr&#39;: ## ## arrange, count, desc, failwith, id, mutate, rename, summarise, ## summarize La fonction update.packages() permet de mettre à jour automatiquement les versions de tous les packages installés. Sous RStudio, on utilisera l’option Update de l’onglet Packages qui permet de sélectionner les packages à mettre à jour. "],["manipulation-des-données-sous-r.html", "Chapitre 3 Manipulation des données sous R 3.1 importer un jeu de données sous R 3.2 Exporter un jeu de données sous R", " Chapitre 3 Manipulation des données sous R 3.1 importer un jeu de données sous R Il existe plusieurs façons d’importer des jeux de données sous R. La méthode la plus courante est d’utiliser la fonction read.csv() ou read.table() pour importer des fichiers CSV ou des fichiers texte tabulés. Ces fonctions peuvent lire des fichiers locaux ou des fichiers à partir d’URL. Vous pouvez également utiliser la fonction read.xlsx() pour importer des fichiers Excel. Les autres méthodes d’importation comprennent l’utilisation des packages R spécialisés pour importer des données à partir de bases de données, d’API Web et d’autres sources. read.csv(“chemin/vers/le/fichier.csv”, header = TRUE, sep = “,”) La fonction ci-dessus prend un paramètre obligatoire qui est le nom de fichier externe en format texte. Il doit être fourni entre guillemets et peut inclure le chemin d’accès au fichier si celui-ci ne se trouve pas dans le répertoire de travail. On peut trouver d’autres paramètres optionnels, comme: Paramètre Description header Une valeur logique (T/F) qui indique si la première ligne contient les noms des colonnes, sinon elles s’appelleront V1, V2… header=F par défaut. sep Le caractère séparant les colonnes du tableau. Par défaut c’est l’espace. Si votre fichier est délimité par des tabulations, utilisez sep= “. dec Le caractère utilisé comme séparateur decimal, par défaut c’est le “.” mais vous pouvez définir la “,” si votre tableau est au format français. row.names Les noms des lignes. Cela peut être un vecteur de même longueur que le nombre de lignes du tableau, mais on utilise souvent le numéro d’une colonne (généralement la première) qui sert alors de label aux lignes et se trouve exclue du tableau. Il existe plusieurs fonctions utiles pour inspecter un tableau de données sous R: str() peut être utilisée pour afficher la structure d’un tableau de données. summary() peut être utilisée pour afficher des statistiques descriptives sur chaque variable. head() et tail() peuvent être utilisées pour afficher les premières et dernières lignes d’un tableau de données. dim() peut être utilisée pour afficher le nombre de lignes et de colonnes dans un tableau de données. colnames() peut être utilisée pour afficher les noms des colonnes. R comprend un certain nombre de jeux de données intégrés. Ces jeux de données sont généralement organisés sous forme de tableaux ou de matrices et peuvent contenir des informations sur les variables, les observations et les caractéristiques de chaque observation. Les jeux de données intégrés à R incluent des données sur le comportement des animaux, le climat, la géographie, la finance et bien plus encore. Les données peuvent être analysées et manipulées à l’aide de fonctions intégrées à R. Il existe également de nombreux packages tiers qui offrent des fonctionnalités supplémentaires pour traiter les données. On utilise ici le jeu de données ChickWeight qui donne les résultats d’une expérimentation visant à comparer le poids des poussins à différents âges en fonction du régime alimentaire reçu. # Charger le jeu de données data(&quot;ChickWeight&quot;) # Afficher les premières lignes du jeu de données head(ChickWeight) ## weight Time Chick Diet ## 1 42 0 1 1 ## 2 51 2 1 1 ## 3 59 4 1 1 ## 4 64 6 1 1 ## 5 76 8 1 1 ## 6 93 10 1 1 # Afficher les informations sur les variables du jeu de données str(ChickWeight) ## Classes &#39;nfnGroupedData&#39;, &#39;nfGroupedData&#39;, &#39;groupedData&#39; and &#39;data.frame&#39;: 578 obs. of 4 variables: ## $ weight: num 42 51 59 64 76 93 106 125 149 171 ... ## $ Time : num 0 2 4 6 8 10 12 14 16 18 ... ## $ Chick : Ord.factor w/ 50 levels &quot;18&quot;&lt;&quot;16&quot;&lt;&quot;15&quot;&lt;..: 15 15 15 15 15 15 15 15 15 15 ... ## $ Diet : Factor w/ 4 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## - attr(*, &quot;formula&quot;)=Class &#39;formula&#39; language weight ~ Time | Chick ## .. ..- attr(*, &quot;.Environment&quot;)=&lt;environment: R_EmptyEnv&gt; ## - attr(*, &quot;outer&quot;)=Class &#39;formula&#39; language ~Diet ## .. ..- attr(*, &quot;.Environment&quot;)=&lt;environment: R_EmptyEnv&gt; ## - attr(*, &quot;labels&quot;)=List of 2 ## ..$ x: chr &quot;Time&quot; ## ..$ y: chr &quot;Body weight&quot; ## - attr(*, &quot;units&quot;)=List of 2 ## ..$ x: chr &quot;(days)&quot; ## ..$ y: chr &quot;(gm)&quot; # Afficher une description statistique des variables du jeu de données summary(ChickWeight) ## weight Time Chick Diet ## Min. : 35.0 Min. : 0.00 13 : 12 1:220 ## 1st Qu.: 63.0 1st Qu.: 4.00 9 : 12 2:120 ## Median :103.0 Median :10.00 20 : 12 3:120 ## Mean :121.8 Mean :10.72 10 : 12 4:118 ## 3rd Qu.:163.8 3rd Qu.:16.00 17 : 12 ## Max. :373.0 Max. :21.00 19 : 12 ## (Other):506 3.2 Exporter un jeu de données sous R Vous pouvez exporter les jeux de données sous R vers d’autres formats de fichier, tels que CSV, TXT ou XLS. Vous pouvez également exporter des jeux de données vers des formats spécifiques à des applications, tels que SPSS, SAS ou Stata. La fonction write.csv() est l’une des fonctions les plus couramment utilisées pour exporter des jeux de données sous R. Elle permet d’exporter des jeux de données vers un fichier CSV. write.csv(data, file = “data.csv”, row.names = FALSE, na = ““) La fonction ci-dessus prend le jeu de données data à exporter. Le paramètre file sauve le jeu de données data sous “data.csv”. Le paramètre row.names indique si les noms de lignes sont incluses ou non dans le fichier csv. Le paramètre na indique la valeur à utiliser pour les valeurs manquantes. Exercice 1: Charger le jeu de données prédéfini mtcars en utilisant la fonction data() de R. Vous pouvez utiliser l’aide R associée à mtcars pour en savoir plus. Explorer le data.frame mtcars en utilisant les fonctions str(), head(), summary() et dim(). Exporter le data.frame mtcars en format texte dans le répertoire de travail sous le nom de mtcars.csv. Ensuite, vérifier la présence du fichier mtcars.csv dans le répertoire de travail et l’ouvrir avec un tableur. Dans ce tableur, ajouter une douzième colonne intitulée mpg_level contenant les valeurs “faible” pour les voitures ayant une consommation en miles par gallon (mpg) inférieure à 20, “moyenne” pour celles ayant une consommation comprise entre 20 et 30, et “élevée” pour celles ayant une consommation supérieure à 30. Enregistrer ce fichier au format texte délimité par des tabulations sous le nom mtcars2.csv. Puis retourner sous R et importer ce fichier de données dans un nouveau data.frame appelé mtcars_new. Vérifiez son contenu sous R avec dim(), head(), etc. On voit que mtcars n’a plus comme nom de ligne, les marques de voitures, mais des chiffres au format caractères. Essayez donc d’attribuer les noms de lignes aux marques de voitures et supprimer la colonne X. "],["statistiques-descriptives-avec-r.html", "Chapitre 4 Statistiques descriptives avec R 4.1 Médianes et quantiles 4.2 La moyenne et la somme 4.3 La variance et l’écart-type", " Chapitre 4 Statistiques descriptives avec R Les statistiques descriptives sont un ensemble de méthodes utilisées pour analyser et interpréter des données. Avec R, vous pouvez facilement réaliser des analyses statistiques descriptives, telles que les moyennes, les écarts-types, les quantiles et bien plus encore. Vous pouvez également créer des graphiques et des tableaux pour mieux comprendre et interpréter vos données. 4.1 Médianes et quantiles Sous R, il est possible de calculer la médiane et les quantiles d’un vecteur ou d’une colonne d’un data.frame à l’aide de fonctions de base. Voici quelques explications: La médiane est la valeur centrale d’un ensemble de données triées par ordre croissant ou décroissant. Elle divise l’ensemble en deux parties égales. En R, la fonction median() permet de calculer la médiane d’un vecteur ou d’une colonne d’un data.frame. #Création d&#39;un vecteur x &lt;- c(3, 5, 6, 9, 10, 12, 15, 18, 19, 20) # Calcul de la médiane median(x) ## [1] 11 Le résultat sera 11, la valeur centrale du vecteur trié par ordre croissant. Les quantiles sont des valeurs qui divisent l’ensemble de données en parts égales. Par exemple, le premier quartile (Q1) est la valeur qui divise les données en deux parties égales, la première moitié ayant des valeurs inférieures ou égales à Q1, et la seconde moitié ayant des valeurs supérieures ou égales à Q1. En R, la fonction quantile() permet de calculer les quantiles d’un vecteur ou d’une colonne d’un data.frame. # Calcul des quartiles d&#39;un vecteur quantile(x, probs = c(0.25, 0.5, 0.75)) ## 25% 50% 75% ## 6.75 11.00 17.25 Ce qui signifie que le premier quartile est 6.75, la médiane est 11, et le troisième quartile est 17.25. 4.2 La moyenne et la somme Sous R, la moyenne et la somme sont deux concepts importants en statistiques et en programmation. Voici comment les calculer : La moyenne est la somme de tous les éléments d’un ensemble de données, divisée par le nombre total d’éléments. En R, vous pouvez calculer la moyenne à l’aide de la fonction mean(). # Créer un vecteur de données x &lt;- c(1, 2, 3, 4, 5) # Calculer la moyenne mean(x) ## [1] 3 Dans cet exemple, la moyenne de 1, 2, 3, 4 et 5 est 3. La somme est la valeur totale de tous les éléments d’un ensemble de données. En R, vous pouvez calculer la somme à l’aide de la fonction sum(). # Créer un vecteur de données x &lt;- c(1, 2, 3, 4, 5) # Calculer la somme sum(x) ## [1] 15 Dans cet exemple, la somme de 1, 2, 3, 4 et 5 est 15. 4.3 La variance et l’écart-type La variance et l’écart-type sont deux mesures importantes de la dispersion des données. La variance est une mesure de la dispersion des données par rapport à leur moyenne (moyenne des carrés des écarts entre chaque valeur de x et la moyenne). En R, vous pouvez calculer la variance à l’aide de la fonction var(). # Créer un vecteur de données x &lt;- c(1, 2, 3, 4, 5) # Calculer la variance var(x) ## [1] 2.5 Dans cet exemple, la variance de 1, 2, 3, 4 et 5 est 2,5. L’écart-type est une mesure de la dispersion des données qui est la racine carrée de la variance, qui a l’avantage de s’exprimer dans la même unité que la moyenne et que les données. En R, vous pouvez calculer l’écart-type à l’aide de la fonction sd(). # Créer un vecteur de données x &lt;- c(1, 2, 3, 4, 5) # Calculer l&#39;écart-type sd(x) ## [1] 1.581139 Dans cet exemple, l’écart-type de 1, 2, 3, 4 et 5 est 1,581139. Il est important de noter que ces fonctions fonctionnent également avec des matrices et des tableaux, où elles effectueront le calcul par colonne par défaut. Vous pouvez également spécifier l’argument “na.rm” pour exclure les valeurs manquantes. Exercices 2: Sur le jeu de données “ChickWeight”, utilisez les fonctions que l’on vient de voir pour faire une description statistique de la colonne weight. "],["régression-linéaire.html", "Chapitre 5 Régression linéaire", " Chapitre 5 Régression linéaire La régression linéaire est une méthode statistique utilisée pour modéliser la relation entre une variable dépendante et une ou plusieurs variables indépendantes. Sous R, il est possible d’effectuer une régression linéaire à l’aide de la fonction lm(). La régression linéaire simple (une seule variable explicative) s’écrit: lm(y~x) Dans l’exemple suivant, on va tester la relation entre le poids et lâge des poussins. #chargement du jeu de données data(&quot;ChickWeight&quot;) m &lt;- lm(weight~Time, data = ChickWeight) summary(m) ## ## Call: ## lm(formula = weight ~ Time, data = ChickWeight) ## ## Residuals: ## Min 1Q Median 3Q Max ## -138.331 -14.536 0.926 13.533 160.669 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 27.4674 3.0365 9.046 &lt;2e-16 *** ## Time 8.8030 0.2397 36.725 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 38.91 on 576 degrees of freedom ## Multiple R-squared: 0.7007, Adjusted R-squared: 0.7002 ## F-statistic: 1349 on 1 and 576 DF, p-value: &lt; 2.2e-16 Ce résultat concerne un modèle de régression linéaire simple pour prédire le poids des poussins en fonction de leur âge. Voici comment interpréter les différents éléments : Call : Cette ligne indique la formule de régression utilisée, qui est “weight ~ Time” et le nom du data.frame utilisé, qui est “ChickWeight”. Coefficients : Cette section présente les coefficients de la régression. L’intercept (l’ordonnée à l’origine) est de 27,4674 et la pente pour la variable “Time” est de 8,8030. Cela signifie que pour chaque unité de temps supplémentaire (jours), le poids des poussins augmente en moyenne de 8,8030. Pr(&gt;|t|) : Cette colonne donne la p-value pour chaque coefficient. Les p-values très faibles (&lt; 0,001) indiquent que les coefficients sont significatifs et que la probabilité d’obtenir une telle valeur de t par hasard est très faible. Residual standard error : C’est une estimation de l’écart-type des résidus. Cela mesure la variabilité non expliquée du modèle. Dans ce cas, l’écart-type est de 38,91. Multiple R-squared : C’est le coefficient de détermination qui mesure la proportion de la variance totale expliquée par le modèle. Ici, le R² est de 0,7007, ce qui indique que le modèle explique 70,07 % de la variance totale des données. F-statistic : Il s’agit d’un test statistique global de la significativité du modèle. Dans ce cas, le F-statistic est de 1349 avec 1 et 576 degrés de liberté, ce qui est très significatif. p-value : C’est la p-value associée au test F et indique la probabilité d’obtenir une telle valeur de F par hasard. La p-value est très faible (&lt; 2,2e-16), ce qui indique que le modèle est très significatif. En résumé, ce modèle de régression linéaire simple montre qu’il existe une relation positive significative entre le poids des poussins et leur âge. Le modèle explique environ 70 % de la variance totale des données et est très significatif. Ajoutons maintenant le régime alimentaire des poussins en compte. Voyons maintenant l’effet de l’âge et du régime alimentaire sur le poids des poussins. Le modèle devient: #chargement du jeu de données data(&quot;ChickWeight&quot;) m &lt;- lm(weight~Time*Diet, data = ChickWeight) summary(m) ## ## Call: ## lm(formula = weight ~ Time * Diet, data = ChickWeight) ## ## Residuals: ## Min 1Q Median 3Q Max ## -135.425 -13.757 -1.311 11.069 130.391 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 30.9310 4.2468 7.283 1.09e-12 *** ## Time 6.8418 0.3408 20.076 &lt; 2e-16 *** ## Diet2 -2.2974 7.2672 -0.316 0.75202 ## Diet3 -12.6807 7.2672 -1.745 0.08154 . ## Diet4 -0.1389 7.2865 -0.019 0.98480 ## Time:Diet2 1.7673 0.5717 3.092 0.00209 ** ## Time:Diet3 4.5811 0.5717 8.014 6.33e-15 *** ## Time:Diet4 2.8726 0.5781 4.969 8.92e-07 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 34.07 on 570 degrees of freedom ## Multiple R-squared: 0.773, Adjusted R-squared: 0.7702 ## F-statistic: 277.3 on 7 and 570 DF, p-value: &lt; 2.2e-16 Cette régression linéaire est un modèle plus complexe que le précédent car il inclut non seulement l’effet de l’âge sur le poids des poussins, mais aussi l’effet du régime alimentaire sur leur poids. De plus, il inclut également une interaction entre l’âge et la diète, ce qui permet d’explorer si l’effet de l’âge sur le poids varie selon la diète. Voici comment interpréter les résultats : Pour l’intercept, Diet1 est pris comme référence. Si nous considérons que la référence (Diet1) a un poids initial moyen de 30.9310g, le coefficient pour Diet2 indique que les poussins ont un poids initial de 28.6336g (30.9310 - 2.2974) lorsqu’ils ont commencé l’expérience. Le coefficient pour Time indique que, toutes choses égales par ailleurs, le poids des poussins augmente de 6.8418g chaque jour qui passe. Les coefficients pour Time:Diet2, Time:Diet3, et Time:Diet4 indiquent l’effet de l’interaction entre le temps et la diète respective sur le poids des poussins. Par exemple, le coefficient pour Time:Diet3 indique que l’effet, de chaque jour supplémentaire sur le poids des poussins, est amplifié de 4.5811g pour les poussins qui reçoivent Diet3, comparé à ceux qui reçoivent la diète de référence. La valeur de l’erreur standard résiduelle (Residual standard error) est de 34.07, ce qui indique l’erreur standard moyenne dans les prévisions du poids des poussins que le modèle ne peut pas expliquer. Le R-carré multiple (Multiple R-squared) indique la proportion de la variance totale qui est expliquée par le modèle, et est égal à 0.773. Cela signifie que le modèle explique environ 77,3% de la variation totale des données. L’ajustement du R-carré (Adjusted R-squared) est égal à 0.7702. Cela signifie que le modèle ajusté explique environ 77,0% de la variation des données. Le test F, avec une statistique de test de 277.3 et une p-value très faible, indique que le modèle dans son ensemble est significatif. En résumé, ce modèle de régression linéaire montre qu’il existe une relation significative à la fois entre le poids des poussins, leur âge et le régime alimentaire reçu. Le modèle explique environ 77 % de la variance totale des données et est très significatif. Exercice 3: Le jeu de données iris intégré dans R contient des mesures sur différentes espèces d’iris. Nous allons utiliser la longueur du pétale (Petal.Length) pour prédire la largeur du pétale (Petal.Width). Charger le jeu de données “iris” en utilisant la fonction data(). Examiner les données en utilisant la fonction head() et summary(). Créer un graphique de dispersion de Petal.Length vs Petal.Width en utilisant la fonction plot(). Ajuster un modèle de régression linéaire simple pour prédire Petal.Width à partir de Petal.Length. Résumer les résultats de la régression en utilisant la fonction summary(). Utiliser le modèle pour faire une prédiction de la largeur du pétale pour une fleur avec une longueur de pétale de 6 cm. Tracer la ligne de régression sur le graphique de dispersion en utilisant la fonction abline(). "],["les-graphiques-avec-r.html", "Chapitre 6 Les graphiques avec R 6.1 Gestion des graphiques sous RStudio 6.2 Quelques fonctions graphiques", " Chapitre 6 Les graphiques avec R 6.1 Gestion des graphiques sous RStudio RStudio possède une fenêtre graphique intégrée où les graphiques peuvent être affichés. Cette fenêtre peut être agrandie, réduite ou mise en plein écran, et permet également de zoomer sur des parties spécifiques du graphique. Cette fenêtre permet également d’enregistrer le graphique dans différents formats de fichiers, tels que PNG, PDF, JPEG, SVG, etc. Affichage d’un graphique sous RStudio! On peut aussi, avant l’appel à la fonction graphique, ouvrir une nouvelle fenêtre graphique avec la fonction x11() qui fonctionne sur Linux et Windows ou son équivalent windows() (Windows uniquement), ou encore quartz() sous MacOS. Le graphique s’affichera toujours dans la dernière fenêtre graphique ouverte qui devient le périphérique (device) actif. On peut également ouvrir directement un fichier graphique avec la fonction pdf(), ou jpeg()… Taper ?Devices pour connaître les différents périphériques utilisables. Dans RStudio, la fonction dev.new() ouvre un nouveau périphérique graphique. La fonction dev.set() permet de sélectionner un périphérique graphique existant. Elle peut être utilisée pour basculer entre les périphériques graphiques ouverts. Par exemple, si vous avez deux périphériques graphiques ouverts, vous pouvez utiliser dev.set(1) pour sélectionner le premier périphérique et dev.set(2) pour sélectionner le deuxième périphérique. La fonction dev.off() ferme le périphérique graphique actif. Cela peut être utile si vous avez plusieurs fenêtres graphiques ouvertes et que vous souhaitez en fermer une. Il est également possible de sauvegarder les graphiques créés dans RStudio en utilisant la fonction dev.copy(). Cette fonction copie le graphique actif vers un périphérique spécifié, tel qu’un fichier PDF ou une image PNG. Par exemple, dev.copy(pdf, “myplot.pdf”) copiera le graphique actif dans un fichier PDF nommé “plot1.pdf”. X11() x &lt;- seq(1,30,0.1) y &lt;- sin(x) plot(x,y, type=&quot;p&quot;) dev.copy(pdf, &quot;plot1.pdf&quot;) dev.off() Enfin, il est possible de personnaliser la sortie graphique en modifiant les options de périphériques graphiques. Par exemple, vous pouvez spécifier la taille de la fenêtre graphique avec options(“dev.size” = c(7, 5)) pour une fenêtre de 7 pouces de large et 5 pouces de haut. Vous pouvez également spécifier le type de périphérique graphique à utiliser par défaut avec options(“device” = “pdf”). 6.2 Quelques fonctions graphiques 6.2.1 La fonction plot() La fonction plot() est une fonction de base de R qui permet de créer des graphiques. Elle est très versatile et permet de créer différents types de graphiques en fonction des arguments passés en entrée. Voici quelques exemples de graphiques que l’on peut créer avec la fonction plot(): Graphique de dispersion (scatterplot): Un graphique de dispersion permet de visualiser la relation entre deux variables continues. On peut créer un tel graphique avec plot() en passant en entrée les valeurs de la première variable sur l’axe des x et les valeurs de la deuxième variable sur l’axe des y. Par exemple: x &lt;- c(1, 2, 3, 4, 5) y &lt;- c(2, 4, 6, 8, 10) plot(x, y) Graphique de ligne: Un graphique de ligne permet de visualiser l’évolution d’une variable en fonction d’une autre variable (souvent une variable temporelle). On peut créer un tel graphique avec plot() en passant en entrée les valeurs de la première variable sur l’axe des x et les valeurs de la deuxième variable sur l’axe des y, et en spécifiant l’option type=“l”. Par exemple: x &lt;- c(1, 2, 3, 4, 5) y &lt;- c(2, 4, 6, 8, 10) plot(x, y, type=&quot;l&quot;) Graphique en boîte (boxplot): Un graphique en boîte permet de visualiser la distribution d’une variable quantitative en fonction d’une variable qualitative. On peut créer un tel graphique avec plot() en passant en entrée la variable quantitative et la variable qualitative sous forme de facteur, et en spécifiant l’option type=“b”. Par exemple: x &lt;- rnorm(100) y &lt;- factor(rep(c(&quot;A&quot;, &quot;B&quot;), each=50)) plot(y, x, type=&quot;b&quot;) 6.2.2 La fonction pairs() La fonction pairs() permet de créer une matrice de nuages de points pour visualiser les relations entre plusieurs variables dans un ensemble de données. Elle prend en entrée une matrice ou un data frame contenant les variables à afficher et affiche une matrice de nuages de points où chaque case représente la relation entre deux variables. Par exemple, supposons que nous avons un data.frame appelé iris contenant les mesures de longueur et de largeur des pétales et des sépales pour trois espèces de fleurs. Pour afficher une matrice de nuages de points pour toutes les combinaisons possibles de ces quatre variables, nous pouvons utiliser la fonction pairs() comme suit: # Charger le jeu de données iris data(&quot;iris&quot;) # Vecteur de couleurs pour chaque espèce cols &lt;- c(&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;) # Utiliser la fonction pairs() avec l&#39;argument col pour colorer chaque point en fonction de l&#39;espèce correspondante pairs(iris[,1:4], col = cols[iris$Species]) Cela va afficher une matrice de 12 nuages de points, montrant les relations entre chaque paire de variables. Ici, nous avons défini le vecteur cols pour contenir une couleur pour chaque espèce (red pour Setosa, green pour Versicolor et blue pour Virginica). Ensuite, nous avons utilisé l’argument col avec le vecteur de couleurs correspondant à chaque espèce (cols[iris$Species]) pour colorer chaque point en fonction de l’espèce correspondante. 6.2.3 La fonction pie() La fonction pie permet de représenter graphiquement des proportions dans un graphique circulaire. x &lt;- c(0.2, 0.3, 0.1, 0.4) pie(x) Le graphique qui en résulte présente un cercle divisé en quatre sections représentant chacune une proportion de l’ensemble. 6.2.4 La fonction hist() La fonction hist() en R est utilisée pour créer un histogramme, qui est un type de graphique qui représente la distribution des valeurs numériques d’un vecteur. L’histogramme est un graphique en barres, où chaque barre représente une plage de valeurs, appelée bin ou classe, et la hauteur de la barre représente le nombre de valeurs dans cette plage. La fonction hist() prend en entrée un vecteur de données numériques et peut également accepter des arguments optionnels pour personnaliser le graphique, tels que le nombre de classes (bins) souhaité, les couleurs des barres, la couleur de fond, les étiquettes des axes, etc. Voici un exemple d’utilisation de la fonction “hist()” pour créer un histogramme à partir d’un vecteur de données numériques “x”: # Créer un vecteur de données x &lt;- c(3, 5, 6, 7, 8, 9, 9, 10, 11, 12, 14, 15, 16, 17, 18, 19, 20) # Créer un histogramme avec 5 classes hist(x, breaks = 5, main = &quot;Histogramme de x&quot;, xlab = &quot;Valeur de x&quot;, ylab = &quot;Fréquence&quot;) Dans cet exemple, la fonction hist() crée un histogramme avec 5 classes en utilisant le vecteur “x”, et l’option breaks. Les options main, xlab, ylab sont utilisées pour ajouter des étiquettes de titre et d’axes au graphique. A la place des fréquences, on peut afficher des densités avec l’option freq=F. On peut également ajouter une courbe de densité en utilisant la fonction lines() par-dessus la fonction de densité density(). # Créer un vecteur de données x &lt;- c(3, 5, 6, 7, 8, 9, 9, 10, 11, 12, 14, 15, 16, 17, 18, 19, 20) # Créer un histogramme avec 5 classes hist(x, breaks = 5, freq=F, main = &quot;Histogramme de x&quot;, ylab = &quot;Densité&quot;, xlab = &quot;Valeur de x&quot;) lines(density(x), col=&quot;green&quot;) On peut récupérer plus d’informations sur l’histogramme en affichant le résultat de la fonction hist. # Créer un vecteur de données x &lt;- c(3, 5, 6, 7, 8, 9, 9, 10, 11, 12, 14, 15, 16, 17, 18, 19, 20) # Créer un histogramme avec 5 classes hist &lt;- hist(x, breaks = 5, freq=F, main = &quot;Histogramme de x&quot;, ylab = &quot;Densité&quot;, xlab = &quot;Valeur de x&quot;) hist ## $breaks ## [1] 0 5 10 15 20 ## ## $counts ## [1] 2 6 4 5 ## ## $density ## [1] 0.02352941 0.07058824 0.04705882 0.05882353 ## ## $mids ## [1] 2.5 7.5 12.5 17.5 ## ## $xname ## [1] &quot;x&quot; ## ## $equidist ## [1] TRUE ## ## attr(,&quot;class&quot;) ## [1] &quot;histogram&quot; Définition des valeurs sorties: $breaks: les bornes des intervalles $counts: le nombre de valeurs par intervalle $density: valeurs de la fonction de densité $mids: valeur centrale des intervalles $xname: nom de la variable x, tel qu’il est affiché sur le graphe $equidist: vrai si les intervalles sont équidistants 6.2.5 La fonction barplot() La fonction barplot() est utilisée pour créer un graphique à barres, également appelé un diagramme à barres. Le diagramme à barres est un graphique qui affiche des données catégorielles sous forme de barres rectangulaires, où la hauteur de chaque barre représente une mesure quantitative associée à cette catégorie. La fonction barplot() prend en entrée un vecteur ou une matrice de données, où chaque colonne représente une catégorie et chaque ligne représente une mesure quantitative pour cette catégorie. Les arguments optionnels peuvent être utilisés pour personnaliser le graphique, tels que les couleurs des barres, les étiquettes des axes, la légende, etc. Voici un exemple d’utilisation de la fonction barplot() pour créer un graphique à barres à partir d’une matrice de données “mat”: # Créer une matrice de données mat &lt;- matrix(c(2, 3, 5, 4, 6, 8), nrow = 2, byrow = TRUE) rownames(mat) &lt;- c(&quot;Hommes&quot;, &quot;Femmes&quot;) colnames(mat) &lt;- c(&quot;Groupe A&quot;, &quot;Groupe B&quot;, &quot;Groupe C&quot;) # Créer un graphique à barres barplot(mat, main = &quot;Graphique à barres&quot;, xlab = &quot;Groupes&quot;, ylab = &quot;Mesures&quot;, col = c(&quot;red&quot;, &quot;blue&quot;), legend.text = rownames(mat)) Dans cet exemple, la fonction barplot() crée un graphique à barres à partir de la matrice de données mat. La fonction rownames() et colnames() sont utilisées pour nommer les lignes et les colonnes de la matrice, qui seront utilisées comme étiquettes d’axe dans le graphique. La fonction barplot() utilise les arguments optionnels pour personnaliser le graphique, tels que les couleurs des barres, les étiquettes des axes, la légende, etc. 6.2.6 La fonction boxplot() La fonction boxplot() est utilisée pour créer un graphique en boîte à moustache. Le graphique affiche la distribution d’un ensemble de données numériques à l’aide de cinq mesures statistiques : la médiane, les quartiles supérieurs et inférieurs, ainsi que les valeurs min et max. Les “moustaches” représentent des intervalles de confiance pour la distribution de données. La fonction boxplot() prend en entrée un ou plusieurs vecteurs de données numériques, où chaque vecteur représente une variable à comparer. Les arguments optionnels peuvent être utilisés pour personnaliser le graphique, tels que les couleurs, les étiquettes des axes, la légende, etc. Voici un exemple d’utilisation de la fonction boxplot() pour créer un boxplot à partir d’un vecteur de données “x”: # Créer un vecteur de données x &lt;- c(10, 20, 30, 40, 50, 60, 70, 80, 90, 100) # Créer un graphique en boîte boxplot(x, main = &quot;boîte à moustache&quot;, ylab = &quot;Valeurs&quot;) Dans cet exemple, la fonction boxplot() crée un graphique à partir du vecteur de données “x”. La fonction utilise les arguments optionnels pour personnaliser le graphique, tels que le titre du graphique et l’étiquette de l’axe y. Les cinq mesures statistiques du vecteur de données sont représentées par la boîte et les moustaches. La boîte représente le quartile supérieur et le quartile inférieur, avec une ligne à l’intérieur représentant la médiane. Les moustaches représentent les valeurs minimum et maximum, avec des points éventuels représentant des valeurs aberrantes. 6.2.7 Les fonctions de tracé de courbes de niveau Les fonctions de tracé de courbes de niveau permettent de représenter des données en 3 dimensions sur un plan en deux dimensions. Cela se fait en créant des courbes de niveau qui relient les points d’une surface ayant la même valeur. Sous R, les fonctions de tracé de courbes de niveau les plus courantes sont contour() et filled.contour(). La fonction contour() trace des courbes de niveau sur un graphique en deux dimensions. Elle prend en entrée une matrice de données ainsi que des arguments supplémentaires qui définissent le nombre et les niveaux de courbes de niveau à afficher. La fonction filled.contour() trace également des courbes de niveau, mais remplit les zones entre les courbes de niveau avec des couleurs pour indiquer les variations de valeur de la surface. Cette fonction prend en entrée une matrice de données ainsi que des arguments supplémentaires qui définissent les niveaux et la palette de couleurs à utiliser pour remplir les zones entre les courbes de niveau. Voici un exemple avec le jeu de données volcano qui contient des données topographiques sur le volcan Maunga Whau (New Zealand) selon une grille régulière de 10m x 10m. data(volcano) # Color palette cols &lt;- hcl.colors(10, &quot;YlOrRd&quot;) contour(volcano, col = cols) filled.contour(volcano, nlevels = 10) 6.2.8 Les fonctions de cartographie Les fonctions cartographiques sous R permettent de créer et de manipuler des cartes géographiques. Voici quelques-unes des fonctions les plus couramment utilisées : maps: cette fonction permet de tracer des cartes géographiques en utilisant des données du package maps. Il est possible de personnaliser les couleurs, les frontières et les légendes de la carte. mapdata: cette fonction permet de télécharger des données géographiques pour une région spécifique. Les données peuvent être utilisées pour tracer des cartes en utilisant la fonction maps. ggmap: cette fonction permet de superposer des données sur des cartes géographiques provenant de Google Maps. Elle peut être utilisée pour créer des cartes interactives. ggplot2: ce package offre de nombreuses fonctionnalités pour la création de cartes géographiques en utilisant la librairie ggplot2. Il permet de créer des cartes thématiques avec des couleurs et des symboles personnalisés. leaflet: cette fonction permet de créer des cartes interactives à l’aide de la bibliothèque JavaScript Leaflet. Elle offre des options pour personnaliser les marqueurs, les popups et les couches de carte. raster: cette fonction permet de manipuler des données raster telles que des images satellites et de créer des cartes à partir de ces données. Elle offre des fonctions pour la classification, la visualisation et la superposition de données raster. sp: ce package offre des fonctionnalités pour la manipulation de données géographiques vectorielles. Il permet de créer des cartes thématiques et d’ajouter des données provenant de sources externes. Ces fonctions cartographiques peuvent être combinées pour créer des cartes géographiques personnalisées et interactives en fonction des besoins de l’utilisateur. library(maps) ## ## Attachement du package : &#39;maps&#39; ## L&#39;objet suivant est masqué depuis &#39;package:plyr&#39;: ## ## ozone library(mapdata) library(ggplot2) # Charger les données de population par ville data(&quot;world.cities&quot;) # Extraire les villes françaises avec une population supérieure à 100 000 france.cities &lt;- subset(world.cities, country.etc == &quot;France&quot; &amp; pop &gt; 100000) # Tracer la carte de la France fr.map &lt;- map(database = &quot;france&quot;, fill = TRUE, col = &quot;lightblue&quot;, bg = &quot;white&quot;, lty = 0, ylim = c(40, 54), xlim = c(-5, 10)) # Créer un graphique ggplot avec la carte de la France # Ajouter des cercles proportionnels pour chaque ville en fonction de leur population ggplot() + geom_polygon(data = fr.map, aes(x = long, y = lat, group = group), fill = &quot;lightblue&quot;, color = &quot;black&quot;) + geom_point(data = france.cities, aes(x = long, y = lat, size = pop), color = &quot;red&quot;, alpha = 0.8) + labs(size = &quot;Taille de la population&quot;)+ coord_fixed(xlim = c(-5, 10), ylim = c(40, 54)) + scale_size_continuous(range = c(1, 10)) Exercice 4: Créez un graphique en nuage de points pour représenter la relation entre le poids et la consommation de carburant de différentes voitures en utilisant le jeu de données mtcars. Créez un graphique en barres empilées pour représenter la répartition des espèces de fleurs dans le jeu de données iris. Créez un graphique en boîtes pour comparer les espérances de vie dans différents pays dans le jeu de données gapminder. Créez un graphique en secteurs pour représenter la répartition des habitants par continent dans le jeu de données gapminder. "],["liens-utiles.html", "Chapitre 7 Liens utiles", " Chapitre 7 Liens utiles Liste de documents utiles: https://cran.r-project.org/manuals.html ou https://cran.r-project.org/other-docs.html Aides utiles: https://www.r-bloggers.com/ ou https://stackoverflow.com/ "]]
